-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic parser combinators
--   
--   This is an industrial-strength monadic parser combinator library.
--   Megaparsec is a feature-rich package that strikes a nice balance
--   between speed, flexibility, and quality of parse errors.
@package megaparsec
@version 6.4.1


-- | Textual source position. The position includes name of file, line
--   number, and column number. List of such positions can be used to model
--   a stack of include files.
--   
--   You probably do not want to import this module directly because
--   <a>Text.Megaparsec</a> re-exports it anyway.
module Text.Megaparsec.Pos

-- | <a>Pos</a> is the type for positive integers. This is used to
--   represent line number, column number, and similar things like
--   indentation level. <a>Semigroup</a> instance can be used to safely and
--   efficiently add <a>Pos</a>es together.
data Pos

-- | Construction of <a>Pos</a> from <a>Int</a>. The function throws
--   <a>InvalidPosException</a> when given a non-positive argument.
mkPos :: Int -> Pos

-- | Extract <a>Int</a> from <a>Pos</a>.
unPos :: Pos -> Int

-- | Position with value 1.
pos1 :: Pos

-- | Value of tab width used by default. Always prefer this constant when
--   you want to refer to the default tab width because actual value
--   <i>may</i> change in future.
defaultTabWidth :: Pos

-- | The exception is thrown by <a>mkPos</a> when its argument is not a
--   positive number.
data InvalidPosException

-- | The first value is the minimal allowed value, the second value is the
--   actual value that was passed to <a>mkPos</a>.
InvalidPosException :: Int -> InvalidPosException

-- | The data type <a>SourcePos</a> represents source positions. It
--   contains the name of the source file, a line number, and a column
--   number. Source line and column positions change intensively during
--   parsing, so we need to make them strict to avoid memory leaks.
data SourcePos
SourcePos :: FilePath -> !Pos -> !Pos -> SourcePos

-- | Name of source file
[sourceName] :: SourcePos -> FilePath

-- | Line number
[sourceLine] :: SourcePos -> !Pos

-- | Column number
[sourceColumn] :: SourcePos -> !Pos

-- | Construct initial position (line 1, column 1) given name of source
--   file.
initialPos :: FilePath -> SourcePos

-- | Pretty-print a <a>SourcePos</a>.
sourcePosPretty :: SourcePos -> String
instance GHC.Generics.Generic Text.Megaparsec.Pos.SourcePos
instance Data.Data.Data Text.Megaparsec.Pos.SourcePos
instance GHC.Classes.Ord Text.Megaparsec.Pos.SourcePos
instance GHC.Classes.Eq Text.Megaparsec.Pos.SourcePos
instance GHC.Read.Read Text.Megaparsec.Pos.SourcePos
instance GHC.Show.Show Text.Megaparsec.Pos.SourcePos
instance GHC.Generics.Generic Text.Megaparsec.Pos.InvalidPosException
instance Data.Data.Data Text.Megaparsec.Pos.InvalidPosException
instance GHC.Show.Show Text.Megaparsec.Pos.InvalidPosException
instance GHC.Classes.Eq Text.Megaparsec.Pos.InvalidPosException
instance Control.DeepSeq.NFData Text.Megaparsec.Pos.Pos
instance Data.Data.Data Text.Megaparsec.Pos.Pos
instance GHC.Classes.Ord Text.Megaparsec.Pos.Pos
instance GHC.Classes.Eq Text.Megaparsec.Pos.Pos
instance GHC.Show.Show Text.Megaparsec.Pos.Pos
instance Control.DeepSeq.NFData Text.Megaparsec.Pos.SourcePos
instance GHC.Exception.Exception Text.Megaparsec.Pos.InvalidPosException
instance Control.DeepSeq.NFData Text.Megaparsec.Pos.InvalidPosException
instance Data.Semigroup.Semigroup Text.Megaparsec.Pos.Pos
instance GHC.Read.Read Text.Megaparsec.Pos.Pos


-- | Megaparsec's input stream facilities.
--   
--   You probably do not want to import this module directly because
--   <a>Text.Megaparsec</a> re-exports it anyway.
module Text.Megaparsec.Stream

-- | Type class for inputs that can be consumed by the library.
class (Ord (Token s), Ord (Tokens s)) => Stream s where {
    type family Token s :: *;
    type family Tokens s :: *;
}

-- | Lift a single token to chunk of the stream. The default implementation
--   is:
--   
--   <pre>
--   tokenToChunk pxy = tokensToChunk pxy . pure
--   </pre>
--   
--   However for some types of stream there may be a more efficient way to
--   lift.
tokenToChunk :: Stream s => Proxy s -> Token s -> Tokens s

-- | The first method that establishes isomorphism between list of tokens
--   and chunk of the stream. Valid implementation should satisfy:
--   
--   <pre>
--   chunkToTokens pxy (tokensToChunk pxy ts) == ts
--   </pre>
tokensToChunk :: Stream s => Proxy s -> [Token s] -> Tokens s

-- | The second method that establishes isomorphism between list of tokens
--   and chunk of the stream. Valid implementation should satisfy:
--   
--   <pre>
--   tokensToChunk pxy (chunkToTokens pxy chunk) == chunk
--   </pre>
chunkToTokens :: Stream s => Proxy s -> Tokens s -> [Token s]

-- | Return length of a chunk of the stream.
chunkLength :: Stream s => Proxy s -> Tokens s -> Int

-- | Check if a chunk of the stream is empty. The default implementation is
--   in terms of the more general <a>chunkLength</a>:
--   
--   <pre>
--   chunkEmpty pxy ts = chunkLength pxy ts &lt;= 0
--   </pre>
--   
--   However for many streams there may be a more efficient implementation.
chunkEmpty :: Stream s => Proxy s -> Tokens s -> Bool

-- | Set source position <b>at</b> given token. By default, the given
--   <a>SourcePos</a> (second argument) is just returned without looking at
--   the token. This method is important when your stream is a collection
--   of tokens where every token knows where it begins in the original
--   input.
positionAt1 :: Stream s => Proxy s -> SourcePos -> Token s -> SourcePos

-- | The same as <a>positionAt1</a>, but for chunks of the stream. The
--   function should return the position where the entire chunk begins.
--   Again, by default the second argument is returned without
--   modifications and the chunk is not looked at.
positionAtN :: Stream s => Proxy s -> SourcePos -> Tokens s -> SourcePos

-- | Advance position given a single token. The returned position is the
--   position right after the token, or the position where the token ends.
advance1 :: Stream s => Proxy s -> Pos -> SourcePos -> Token s -> SourcePos

-- | Advance position given a chunk of stream. The returned position is the
--   position right after the chunk, or the position where the chunk ends.
advanceN :: Stream s => Proxy s -> Pos -> SourcePos -> Tokens s -> SourcePos

-- | Extract a single token form the stream. Return <a>Nothing</a> if the
--   stream is empty.
take1_ :: Stream s => s -> Maybe (Token s, s)

-- | <tt><a>takeN_</a> n s</tt> should try to extract a chunk of length
--   <tt>n</tt>, or if the stream is too short, the rest of the stream.
--   Valid implementation should follow the rules:
--   
--   <ul>
--   <li>If the requested length <tt>n</tt> is 0 (or less), <a>Nothing</a>
--   should never be returned, instead <tt><a>Just</a> ("", s)</tt> should
--   be returned, where <tt>""</tt> stands for the empty chunk, and
--   <tt>s</tt> is the original stream (second argument).</li>
--   <li>If the requested length is greater than 0 and the stream is empty,
--   <a>Nothing</a> should be returned indicating end of input.</li>
--   <li>In other cases, take chunk of length <tt>n</tt> (or shorter if the
--   stream is not long enough) from the input stream and return the chunk
--   along with the rest of the stream.</li>
--   </ul>
takeN_ :: Stream s => Int -> s -> Maybe (Tokens s, s)

-- | Extract chunk of the stream taking tokens while the supplied predicate
--   returns <a>True</a>. Return the chunk and the rest of the stream.
--   
--   For many types of streams, the method allows for significant
--   performance improvements, although it is not strictly necessary from
--   conceptual point of view.
takeWhile_ :: Stream s => (Token s -> Bool) -> s -> (Tokens s, s)
instance Text.Megaparsec.Stream.Stream GHC.Base.String
instance Text.Megaparsec.Stream.Stream Data.ByteString.Internal.ByteString
instance Text.Megaparsec.Stream.Stream Data.ByteString.Lazy.Internal.ByteString
instance Text.Megaparsec.Stream.Stream Data.Text.Internal.Text
instance Text.Megaparsec.Stream.Stream Data.Text.Internal.Lazy.Text


-- | Parse errors. Current version of Megaparsec supports well-typed errors
--   instead of <a>String</a>-based ones. This gives a lot of flexibility
--   in describing what exactly went wrong as well as a way to return
--   arbitrary data in case of failure.
--   
--   You probably do not want to import this module directly because
--   <a>Text.Megaparsec</a> re-exports it anyway.
module Text.Megaparsec.Error

-- | Data type that is used to represent “unexpected/expected” items in
--   <a>ParseError</a>. The data type is parametrized over the token type
--   <tt>t</tt>.
data ErrorItem t

-- | Non-empty stream of tokens
Tokens :: (NonEmpty t) -> ErrorItem t

-- | Label (cannot be empty)
Label :: (NonEmpty Char) -> ErrorItem t

-- | End of input
EndOfInput :: ErrorItem t

-- | Additional error data, extendable by user. When no custom data is
--   necessary, the type is typically indexed by <a>Void</a> to “cancel”
--   the <a>ErrorCustom</a> constructor.
data ErrorFancy e

-- | <a>fail</a> has been used in parser monad
ErrorFail :: String -> ErrorFancy e

-- | Incorrect indentation error: desired ordering between reference level
--   and actual level, reference indentation level, actual indentation
--   level
ErrorIndentation :: Ordering -> Pos -> Pos -> ErrorFancy e

-- | Custom error data, can be conveniently disabled by indexing
--   <a>ErrorFancy</a> by <a>Void</a>
ErrorCustom :: e -> ErrorFancy e

-- | <tt><a>ParseError</a> t e</tt> represents a parse error parametrized
--   over the token type <tt>t</tt> and the custom data <tt>e</tt>.
--   
--   Note that the stack of source positions contains current position as
--   its head, and the rest of positions allows to track full sequence of
--   include files with topmost source file at the end of the list.
--   
--   <a>Semigroup</a> and <a>Monoid</a> instances of the data type allow to
--   merge parse errors from different branches of parsing. When merging
--   two <a>ParseError</a>s, the longest match is preferred; if positions
--   are the same, custom data sets and collections of message items are
--   combined. Note that fancy errors take precedence over trivial errors
--   in merging.
data ParseError t e

-- | Trivial errors, generated by Megaparsec's machinery. The data
--   constructor includes the stack of source positions, unexpected token
--   (if any), and expected tokens.
TrivialError :: (NonEmpty SourcePos) -> (Maybe (ErrorItem t)) -> (Set (ErrorItem t)) -> ParseError t e

-- | Fancy, custom errors.
FancyError :: (NonEmpty SourcePos) -> (Set (ErrorFancy e)) -> ParseError t e

-- | Get position of given <a>ParseError</a>.
errorPos :: ParseError t e -> NonEmpty SourcePos

-- | Type class <a>ShowToken</a> includes methods that allow to
--   pretty-print single token as well as stream of tokens. This is used
--   for rendering of error messages.
class ShowToken a

-- | Pretty-print non-empty stream of tokens. This function is also used to
--   print single tokens (represented as singleton lists).
showTokens :: ShowToken a => NonEmpty a -> String

-- | Type class for tokens that support operations necessary for selecting
--   and displaying relevant line of input.
class LineToken a

-- | Convert a token to a <a>Char</a>. This is used to print relevant line
--   from input stream by turning a list of tokens into a <a>String</a>.
tokenAsChar :: LineToken a => a -> Char

-- | Check if given token is a newline or contains newline.
tokenIsNewline :: LineToken a => a -> Bool

-- | The type class defines how to print custom data component of
--   <a>ParseError</a>.
class Ord a => ShowErrorComponent a

-- | Pretty-print custom data component of <a>ParseError</a>.
showErrorComponent :: ShowErrorComponent a => a -> String

-- | Pretty-print a <a>ParseError</a>. The rendered <a>String</a> always
--   ends with a newline.
parseErrorPretty :: (Ord t, ShowToken t, ShowErrorComponent e) => ParseError t e -> String

-- | Pretty-print a <a>ParseError</a> and display the line on which the
--   parse error occurred. The rendered <a>String</a> always ends with a
--   newline.
--   
--   Note that if you work with include files and have a stack of
--   <a>SourcePos</a>es in <a>ParseError</a>, it's up to you to provide
--   correct input stream corresponding to the file in which parse error
--   actually happened.
--   
--   <a>parseErrorPretty'</a> is defined in terms of the more general
--   <a>parseErrorPretty_</a> function which allows to specify tab width as
--   well:
--   
--   <pre>
--   parseErrorPretty' = parseErrorPretty_ defaultTabWidth
--   </pre>
parseErrorPretty' :: (ShowToken (Token s), LineToken (Token s), ShowErrorComponent e, Stream s) => s -> ParseError (Token s) e -> String

-- | Just like <a>parseErrorPretty'</a>, but allows to specify tab width.
parseErrorPretty_ :: forall s e. (ShowToken (Token s), LineToken (Token s), ShowErrorComponent e, Stream s) => Pos -> s -> ParseError (Token s) e -> String

-- | Pretty-print a stack of source positions.
sourcePosStackPretty :: NonEmpty SourcePos -> String

-- | Pretty-print a textual part of a <a>ParseError</a>, that is,
--   everything except stack of source positions. The rendered staring
--   always ends with a new line.
parseErrorTextPretty :: (Ord t, ShowToken t, ShowErrorComponent e) => ParseError t e -> String
instance GHC.Generics.Generic (Text.Megaparsec.Error.ParseError t e)
instance (GHC.Classes.Ord e, GHC.Classes.Ord t, Data.Data.Data e, Data.Data.Data t) => Data.Data.Data (Text.Megaparsec.Error.ParseError t e)
instance (GHC.Classes.Eq e, GHC.Classes.Eq t) => GHC.Classes.Eq (Text.Megaparsec.Error.ParseError t e)
instance (GHC.Classes.Ord e, GHC.Classes.Ord t, GHC.Read.Read e, GHC.Read.Read t) => GHC.Read.Read (Text.Megaparsec.Error.ParseError t e)
instance (GHC.Show.Show e, GHC.Show.Show t) => GHC.Show.Show (Text.Megaparsec.Error.ParseError t e)
instance GHC.Base.Functor Text.Megaparsec.Error.ErrorFancy
instance GHC.Generics.Generic (Text.Megaparsec.Error.ErrorFancy e)
instance Data.Data.Data e => Data.Data.Data (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Classes.Ord e => GHC.Classes.Ord (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Read.Read e => GHC.Read.Read (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Show.Show e => GHC.Show.Show (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Base.Functor Text.Megaparsec.Error.ErrorItem
instance GHC.Generics.Generic (Text.Megaparsec.Error.ErrorItem t)
instance Data.Data.Data t => Data.Data.Data (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Read.Read t => GHC.Read.Read (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Show.Show t => GHC.Show.Show (Text.Megaparsec.Error.ErrorItem t)
instance (GHC.Show.Show t, GHC.Classes.Ord t, Text.Megaparsec.Error.ShowToken t, Data.Typeable.Internal.Typeable t, GHC.Show.Show e, Text.Megaparsec.Error.ShowErrorComponent e, Data.Typeable.Internal.Typeable e) => GHC.Exception.Exception (Text.Megaparsec.Error.ParseError t e)
instance (GHC.Classes.Ord t, Text.Megaparsec.Error.ShowToken t) => Text.Megaparsec.Error.ShowErrorComponent (Text.Megaparsec.Error.ErrorItem t)
instance Text.Megaparsec.Error.ShowErrorComponent e => Text.Megaparsec.Error.ShowErrorComponent (Text.Megaparsec.Error.ErrorFancy e)
instance Text.Megaparsec.Error.ShowErrorComponent Data.Void.Void
instance Text.Megaparsec.Error.LineToken GHC.Types.Char
instance Text.Megaparsec.Error.LineToken GHC.Word.Word8
instance Text.Megaparsec.Error.ShowToken GHC.Types.Char
instance Text.Megaparsec.Error.ShowToken GHC.Word.Word8
instance (Control.DeepSeq.NFData t, Control.DeepSeq.NFData e) => Control.DeepSeq.NFData (Text.Megaparsec.Error.ParseError t e)
instance (GHC.Classes.Ord t, GHC.Classes.Ord e) => Data.Semigroup.Semigroup (Text.Megaparsec.Error.ParseError t e)
instance (GHC.Classes.Ord t, GHC.Classes.Ord e) => GHC.Base.Monoid (Text.Megaparsec.Error.ParseError t e)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Text.Megaparsec.Error.ErrorFancy a)
instance Control.DeepSeq.NFData t => Control.DeepSeq.NFData (Text.Megaparsec.Error.ErrorItem t)


-- | A set of helpers that should make construction of <a>ParseError</a>s
--   more concise. This is primarily useful in test suites and for
--   debugging, you most certainly don't need it for normal usage.
module Text.Megaparsec.Error.Builder

-- | Assemble a <a>ParseError</a> from source position and <tt><a>ET</a>
--   t</tt> value. To create source position, two helpers are available:
--   <a>posI</a> and <a>posN</a>. <tt><a>ET</a> t</tt> is a monoid and can
--   be assembled by combining primitives provided by this module, see
--   below.
err :: NonEmpty SourcePos -> ET t -> ParseError t e

-- | Like <a>err</a>, but constructs a “fancy” <a>ParseError</a>.
errFancy :: NonEmpty SourcePos -> EF e -> ParseError t e

-- | Initial source position with empty file name.
posI :: NonEmpty SourcePos

-- | <tt><a>posN</a> n s</tt> returns source position achieved by applying
--   <a>advanceN</a> method corresponding to the type of stream <tt>s</tt>.
posN :: forall s. Stream s => Int -> s -> NonEmpty SourcePos

-- | Construct an “unexpected token” error component.
utok :: Ord t => t -> ET t

-- | Construct an “unexpected tokens” error component. Empty string
--   produces <a>EndOfInput</a>.
utoks :: Ord t => [t] -> ET t

-- | Construct an “unexpected label” error component. Do not use with empty
--   strings (for empty strings it's bottom).
ulabel :: Ord t => String -> ET t

-- | Construct an “unexpected end of input” error component.
ueof :: Ord t => ET t

-- | Construct an “expected token” error component.
etok :: Ord t => t -> ET t

-- | Construct an “expected tokens” error component. Empty string produces
--   <a>EndOfInput</a>.
etoks :: Ord t => [t] -> ET t

-- | Construct an “expected label” error component. Do not use with empty
--   strings.
elabel :: Ord t => String -> ET t

-- | Construct an “expected end of input” error component.
eeof :: Ord t => ET t

-- | Construct a custom error component.
fancy :: ErrorFancy e -> EF e

-- | Auxiliary type for construction of trivial parse errors.
data ET t

-- | Auxiliary type for construction of fancy parse errors.
data EF e
instance GHC.Generics.Generic (Text.Megaparsec.Error.Builder.EF e)
instance (GHC.Classes.Ord e, Data.Data.Data e) => Data.Data.Data (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Ord e => GHC.Classes.Ord (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Generics.Generic (Text.Megaparsec.Error.Builder.ET t)
instance (GHC.Classes.Ord t, Data.Data.Data t) => Data.Data.Data (Text.Megaparsec.Error.Builder.ET t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (Text.Megaparsec.Error.Builder.ET t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Text.Megaparsec.Error.Builder.ET t)
instance GHC.Classes.Ord e => Data.Semigroup.Semigroup (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Ord e => GHC.Base.Monoid (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Ord t => Data.Semigroup.Semigroup (Text.Megaparsec.Error.Builder.ET t)
instance GHC.Classes.Ord t => GHC.Base.Monoid (Text.Megaparsec.Error.Builder.ET t)


-- | This module includes everything you need to get started writing a
--   parser. If you are new to Megaparsec and don't know where to begin,
--   take a look at the tutorials
--   <a>https://markkarpov.com/learn-haskell.html#megaparsec-tutorials</a>.
--   
--   In addition to the <a>Text.Megaparsec</a> module, which exports and
--   re-exports most everything that you may need, we advise to import
--   <a>Text.Megaparsec.Char</a> if you plan to work with a stream of
--   <a>Char</a> tokens or <a>Text.Megaparsec.Byte</a> if you intend to
--   parse binary data.
--   
--   It is common to start working with the library by defining a type
--   synonym like this:
--   
--   <pre>
--   type Parser = Parsec Void Text
--                        ^    ^
--                        |    |
--   Custom error component    Type of input
--   </pre>
--   
--   Then you can write type signatures like <tt>Parser Int</tt>—for a
--   parser that returns an <a>Int</a> for example.
--   
--   Similarly (since it's known to cause confusion), you should use
--   <a>ParseError</a> type parametrized like this:
--   
--   <pre>
--   ParseError Char Void
--              ^    ^
--              |    |
--     Token type    Custom error component (the same you used in Parser)
--   </pre>
--   
--   Token type for <a>String</a> and <a>Text</a> (strict and lazy) is
--   <a>Char</a>, for <a>ByteString</a>s it's <a>Word8</a>.
--   
--   Megaparsec uses some type-level machinery to provide flexibility
--   without compromising on type safety. Thus type signatures are
--   sometimes necessary to avoid ambiguous types. If you're seeing a error
--   message that reads like “Type variable <tt>e0</tt> is ambiguous …”,
--   you need to give an explicit signature to your parser to resolve the
--   ambiguity. It's a good idea to provide type signatures for all
--   top-level definitions.
--   
--   Megaparsec is capable of a lot. Apart from this standard functionality
--   you can parse permutation phrases with <a>Text.Megaparsec.Perm</a>,
--   expressions with <a>Text.Megaparsec.Expr</a>, do lexing with
--   <a>Text.Megaparsec.Char.Lexer</a> and
--   <a>Text.Megaparsec.Byte.Lexer</a>. These modules should be imported
--   explicitly along with the modules mentioned above.
module Text.Megaparsec

-- | This is the Megaparsec's state parametrized over stream type
--   <tt>s</tt>.
data State s
State :: s -> NonEmpty SourcePos -> {-# UNPACK #-} !Int -> Pos -> State s

-- | The rest of input to process
[stateInput] :: State s -> s

-- | Current position (column + line number) with support for include files
[statePos] :: State s -> NonEmpty SourcePos

-- | Number of processed tokens so far
[stateTokensProcessed] :: State s -> {-# UNPACK #-} !Int

-- | Tab width to use
[stateTabWidth] :: State s -> Pos

-- | <a>Parsec</a> is a non-transformer variant of the more general
--   <a>ParsecT</a> monad transformer.
type Parsec e s = ParsecT e s Identity

-- | <tt><a>ParsecT</a> e s m a</tt> is a parser with custom data component
--   of error <tt>e</tt>, stream type <tt>s</tt>, underlying monad
--   <tt>m</tt> and return type <tt>a</tt>.
data ParsecT e s m a

-- | <tt><a>parse</a> p file input</tt> runs parser <tt>p</tt> over
--   <a>Identity</a> (see <a>runParserT</a> if you're using the
--   <a>ParsecT</a> monad transformer; <a>parse</a> itself is just a
--   synonym for <a>runParser</a>). It returns either a <a>ParseError</a>
--   (<a>Left</a>) or a value of type <tt>a</tt> (<a>Right</a>).
--   <a>parseErrorPretty</a> can be used to turn <a>ParseError</a> into the
--   string representation of the error message. See
--   <a>Text.Megaparsec.Error</a> if you need to do more advanced error
--   analysis.
--   
--   <pre>
--   main = case (parse numbers "" "11,2,43") of
--            Left err -&gt; putStr (parseErrorPretty err)
--            Right xs -&gt; print (sum xs)
--   
--   numbers = integer `sepBy` char ','
--   </pre>
parse :: Parsec e s a -> String -> s -> Either (ParseError (Token s) e) a

-- | <tt><a>parseMaybe</a> p input</tt> runs the parser <tt>p</tt> on
--   <tt>input</tt> and returns the result inside <a>Just</a> on success
--   and <a>Nothing</a> on failure. This function also parses <a>eof</a>,
--   so if the parser doesn't consume all of its input, it will fail.
--   
--   The function is supposed to be useful for lightweight parsing, where
--   error messages (and thus file name) are not important and entire input
--   should be parsed. For example, it can be used when parsing of a single
--   number according to a specification of its format is desired.
parseMaybe :: (Ord e, Stream s) => Parsec e s a -> s -> Maybe a

-- | The expression <tt><a>parseTest</a> p input</tt> applies the parser
--   <tt>p</tt> against input <tt>input</tt> and prints the result to
--   stdout. Useful for testing.
parseTest :: (ShowErrorComponent e, Ord (Token s), ShowToken (Token s), Show a) => Parsec e s a -> s -> IO ()

-- | A version of <a>parseTest</a> that also prints offending line in parse
--   errors.
parseTest' :: (ShowErrorComponent e, ShowToken (Token s), LineToken (Token s), Show a, Stream s) => Parsec e s a -> s -> IO ()

-- | <tt><a>runParser</a> p file input</tt> runs parser <tt>p</tt> on the
--   input stream of tokens <tt>input</tt>, obtained from source
--   <tt>file</tt>. The <tt>file</tt> is only used in error messages and
--   may be the empty string. Returns either a <a>ParseError</a>
--   (<a>Left</a>) or a value of type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   parseFromFile p file = runParser p file &lt;$&gt; readFile file
--   </pre>
runParser :: Parsec e s a -> String -> s -> Either (ParseError (Token s) e) a

-- | The function is similar to <a>runParser</a> with the difference that
--   it accepts and returns parser state. This allows to specify arbitrary
--   textual position at the beginning of parsing, for example. This is the
--   most general way to run a parser over the <a>Identity</a> monad.
runParser' :: Parsec e s a -> State s -> (State s, Either (ParseError (Token s) e) a)

-- | <tt><a>runParserT</a> p file input</tt> runs parser <tt>p</tt> on the
--   input list of tokens <tt>input</tt>, obtained from source
--   <tt>file</tt>. The <tt>file</tt> is only used in error messages and
--   may be the empty string. Returns a computation in the underlying monad
--   <tt>m</tt> that returns either a <a>ParseError</a> (<a>Left</a>) or a
--   value of type <tt>a</tt> (<a>Right</a>).
runParserT :: Monad m => ParsecT e s m a -> String -> s -> m (Either (ParseError (Token s) e) a)

-- | This function is similar to <a>runParserT</a>, but like
--   <a>runParser'</a> it accepts and returns parser state. This is thus
--   the most general way to run a parser.
runParserT' :: Monad m => ParsecT e s m a -> State s -> m (State s, Either (ParseError (Token s) e) a)

-- | Type class describing monads that implement the full set of primitive
--   parsers.
--   
--   <b>Note carefully</b> that the following primitives are “fast” and
--   should be taken advantage of as much as possible if your aim is a fast
--   parser: <a>tokens</a>, <a>takeWhileP</a>, <a>takeWhile1P</a>, and
--   <a>takeP</a>.
class (Stream s, Alternative m, MonadPlus m) => MonadParsec e s m | m -> e s

-- | The most general way to stop parsing and report a trivial
--   <a>ParseError</a>.
failure :: MonadParsec e s m => Maybe (ErrorItem (Token s)) -> Set (ErrorItem (Token s)) -> m a

-- | The most general way to stop parsing and report a fancy
--   <a>ParseError</a>. To report a single custom parse error, see
--   <a>customFailure</a>.
fancyFailure :: MonadParsec e s m => Set (ErrorFancy e) -> m a

-- | The parser <tt><a>label</a> name p</tt> behaves as parser <tt>p</tt>,
--   but whenever the parser <tt>p</tt> fails <i>without consuming any
--   input</i>, it replaces names of “expected” tokens with the name
--   <tt>name</tt>.
label :: MonadParsec e s m => String -> m a -> m a

-- | <tt><a>hidden</a> p</tt> behaves just like parser <tt>p</tt>, but it
--   doesn't show any “expected” tokens in error message when <tt>p</tt>
--   fails.
--   
--   Please use <a>hidden</a> instead of the old <tt><a>label</a> ""</tt>
--   idiom.
hidden :: MonadParsec e s m => m a -> m a

-- | The parser <tt><a>try</a> p</tt> behaves like parser <tt>p</tt>,
--   except that it backtracks the parser state when <tt>p</tt> fails
--   (either consuming input or not).
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   if the first parser failed while consuming input.
--   
--   For example, here is a parser that is supposed to parse the word “let”
--   or the word “lexical”:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string "let" &lt;|&gt; string "lexical") "lexical"
--   1:1:
--   unexpected "lex"
--   expecting "let"
--   </pre>
--   
--   What happens here? The first parser consumes “le” and fails (because
--   it doesn't see a “t”). The second parser, however, isn't tried, since
--   the first parser has already consumed some input! <a>try</a> fixes
--   this behavior and allows backtracking to work:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "lexical"
--   "lexical"
--   </pre>
--   
--   <a>try</a> also improves error messages in case of overlapping
--   alternatives, because Megaparsec's hint system can be used:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "le"
--   1:1:
--   unexpected "le"
--   expecting "let" or "lexical"
--   </pre>
--   
--   <b>Please note</b> that as of Megaparsec 4.4.0, <tt>string</tt>
--   backtracks automatically (see <a>tokens</a>), so it does not need
--   <a>try</a>. However, the examples above demonstrate the idea behind
--   <a>try</a> so well that it was decided to keep them. You still need to
--   use <a>try</a> when your alternatives are complex, composite parsers.
try :: MonadParsec e s m => m a -> m a

-- | If <tt>p</tt> in <tt><a>lookAhead</a> p</tt> succeeds (either
--   consuming input or not) the whole parser behaves like <tt>p</tt>
--   succeeded without consuming anything (parser state is not updated as
--   well). If <tt>p</tt> fails, <a>lookAhead</a> has no effect, i.e. it
--   will fail consuming input if <tt>p</tt> fails consuming input. Combine
--   with <a>try</a> if this is undesirable.
lookAhead :: MonadParsec e s m => m a -> m a

-- | <tt><a>notFollowedBy</a> p</tt> only succeeds when the parser
--   <tt>p</tt> fails. This parser <i>never consumes</i> any input and
--   <i>never modifies</i> parser state. It can be used to implement the
--   “longest match” rule.
notFollowedBy :: MonadParsec e s m => m a -> m ()

-- | <tt><a>withRecovery</a> r p</tt> allows continue parsing even if
--   parser <tt>p</tt> fails. In this case <tt>r</tt> is called with the
--   actual <a>ParseError</a> as its argument. Typical usage is to return a
--   value signifying failure to parse this particular object and to
--   consume some part of the input up to the point where the next object
--   starts.
--   
--   Note that if <tt>r</tt> fails, original error message is reported as
--   if without <a>withRecovery</a>. In no way recovering parser <tt>r</tt>
--   can influence error messages.
withRecovery :: MonadParsec e s m => (ParseError (Token s) e -> m a) -> m a -> m a

-- | <tt><a>observing</a> p</tt> allows to “observe” failure of the
--   <tt>p</tt> parser, should it happen, without actually ending parsing,
--   but instead getting the <a>ParseError</a> in <a>Left</a>. On success
--   parsed value is returned in <a>Right</a> as usual. Note that this
--   primitive just allows you to observe parse errors as they happen, it
--   does not backtrack or change how the <tt>p</tt> parser works in any
--   way.
observing :: MonadParsec e s m => m a -> m (Either (ParseError (Token s) e) a)

-- | This parser only succeeds at the end of the input.
eof :: MonadParsec e s m => m ()

-- | The parser <tt><a>token</a> test mrep</tt> accepts a token <tt>t</tt>
--   with result <tt>x</tt> when the function <tt>test t</tt> returns
--   <tt><a>Right</a> x</tt>. <tt>mrep</tt> may provide representation of
--   the token to report in error messages when input stream in empty.
--   
--   This is the most primitive combinator for accepting tokens. For
--   example, the <a>satisfy</a> parser is implemented as:
--   
--   <pre>
--   satisfy f = token testChar Nothing
--     where
--       testChar x =
--         if f x
--           then Right x
--           else Left (pure (Tokens (x:|[])), Set.empty)
--   </pre>
token :: MonadParsec e s m => (Token s -> Either (Maybe (ErrorItem (Token s)), Set (ErrorItem (Token s))) a) -> Maybe (Token s) -> m a

-- | The parser <tt><a>tokens</a> test</tt> parses a chunk of input and
--   returns it. Supplied predicate <tt>test</tt> is used to check equality
--   of given and parsed chunks after a candidate chunk of correct length
--   is fetched from the stream.
--   
--   This can be used for example to write <a>string</a>:
--   
--   <pre>
--   string = tokens (==)
--   </pre>
--   
--   Note that beginning from Megaparsec 4.4.0, this is an
--   auto-backtracking primitive, which means that if it fails, it never
--   consumes any input. This is done to make its consumption model match
--   how error messages for this primitive are reported (which becomes an
--   important thing as user gets more control with primitives like
--   <a>withRecovery</a>):
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string "abc") "abd"
--   1:1:
--   unexpected "abd"
--   expecting "abc"
--   </pre>
--   
--   This means, in particular, that it's no longer necessary to use
--   <a>try</a> with <a>tokens</a>-based parsers, such as <a>string</a> and
--   <a>string'</a>. This feature <i>does not</i> affect performance in any
--   way.
tokens :: MonadParsec e s m => (Tokens s -> Tokens s -> Bool) -> Tokens s -> m (Tokens s)

-- | Parse <i>zero</i> or more tokens for which the supplied predicate
--   holds. Try to use this as much as possible because for many streams
--   the combinator is much faster than parsers built with <a>many</a> and
--   <a>satisfy</a>.
--   
--   The following equations should clarify the behavior:
--   
--   <pre>
--   takeWhileP (Just "foo") f = many (satisfy f &lt;?&gt; "foo")
--   takeWhileP Nothing      f = many (satisfy f)
--   </pre>
--   
--   The combinator never fails, although it may parse an empty chunk.
takeWhileP :: MonadParsec e s m => Maybe String -> (Token s -> Bool) -> m (Tokens s)

-- | Similar to <a>takeWhileP</a>, but fails if it can't parse at least one
--   token. Note that the combinator either succeeds or fails without
--   consuming any input, so <a>try</a> is not necessary with it.
takeWhile1P :: MonadParsec e s m => Maybe String -> (Token s -> Bool) -> m (Tokens s)

-- | Extract the specified number of tokens from the input stream and
--   return them packed as a chunk of stream. If there is not enough tokens
--   in the stream, a parse error will be signaled. It's guaranteed that if
--   the parser succeeds, the requested number of tokens will be returned.
--   
--   The parser is roughly equivalent to:
--   
--   <pre>
--   takeP (Just "foo") n = count n (anyChar &lt;?&gt; "foo")
--   takeP Nothing      n = count n anyChar
--   </pre>
--   
--   Note that if the combinator fails due to insufficient number of tokens
--   in the input stream, it backtracks automatically. No <a>try</a> is
--   necessary with <a>takeP</a>.
takeP :: MonadParsec e s m => Maybe String -> Int -> m (Tokens s)

-- | Return the full parser state as a <a>State</a> record.
getParserState :: MonadParsec e s m => m (State s)

-- | <tt><a>updateParserState</a> f</tt> applies the function <tt>f</tt> to
--   the parser state.
updateParserState :: MonadParsec e s m => (State s -> State s) -> m ()

-- | A synonym for <a>label</a> in the form of an operator.
(<?>) :: MonadParsec e s m => m a -> String -> m a
infix 0 <?>

-- | The parser <tt><a>unexpected</a> item</tt> fails with an error message
--   telling about unexpected item <tt>item</tt> without consuming any
--   input.
--   
--   <pre>
--   unexpected item = failure (pure item) Set.empty
--   </pre>
unexpected :: MonadParsec e s m => ErrorItem (Token s) -> m a

-- | Report a custom parse error. For a more general version, see
--   <a>fancyFailure</a>.
customFailure :: MonadParsec e s m => e -> m a

-- | Return both the result of a parse and a chunk of input that was
--   consumed during parsing. This relies on the change of the
--   <a>stateTokensProcessed</a> value to evaluate how many tokens were
--   consumed. If you mess with it manually in the argument parser, prepare
--   for troubles.
match :: MonadParsec e s m => m a -> m (Tokens s, a)

-- | Specify how to process <a>ParseError</a>s that happen inside of this
--   wrapper. As a side effect of the current implementation changing
--   <a>errorPos</a> with this combinator will also change the final
--   <a>statePos</a> in the parser state (try to avoid that because
--   <a>statePos</a> will go out of sync with factual position in the input
--   stream, which is probably OK if you finish parsing right after that,
--   but be warned).
region :: MonadParsec e s m => (ParseError (Token s) e -> ParseError (Token s) e) -> m a -> m a

-- | Consume the rest of the input and return it as a chunk. This parser
--   never fails, but may return an empty chunk.
--   
--   <pre>
--   takeRest = takeWhileP Nothing (const True)
--   </pre>
takeRest :: MonadParsec e s m => m (Tokens s)

-- | Return <a>True</a> when end of input has been reached.
atEnd :: MonadParsec e s m => m Bool

-- | Return the current input.
getInput :: MonadParsec e s m => m s

-- | <tt><a>setInput</a> input</tt> continues parsing with <tt>input</tt>.
--   The <a>getInput</a> and <a>setInput</a> functions can for example be
--   used to deal with include files.
setInput :: MonadParsec e s m => s -> m ()

-- | Return the current source position.
--   
--   See also: <a>setPosition</a>, <a>pushPosition</a>, <a>popPosition</a>,
--   and <a>SourcePos</a>.
getPosition :: MonadParsec e s m => m SourcePos

-- | Get the position where the next token in the stream begins. If the
--   stream is empty, return <a>Nothing</a>.
getNextTokenPosition :: forall e s m. MonadParsec e s m => m (Maybe SourcePos)

-- | <tt><a>setPosition</a> pos</tt> sets the current source position to
--   <tt>pos</tt>.
--   
--   See also: <a>getPosition</a>, <a>pushPosition</a>, <a>popPosition</a>,
--   and <a>SourcePos</a>.
setPosition :: MonadParsec e s m => SourcePos -> m ()

-- | Push a position into stack of positions and continue parsing working
--   with this position. Useful for working with include files and the
--   like.
--   
--   See also: <a>getPosition</a>, <a>setPosition</a>, <a>popPosition</a>,
--   and <a>SourcePos</a>.
pushPosition :: MonadParsec e s m => SourcePos -> m ()

-- | Pop a position from the stack of positions unless it only contains one
--   element (in that case the stack of positions remains the same). This
--   is how to return to previous source file after <a>pushPosition</a>.
--   
--   See also: <a>getPosition</a>, <a>setPosition</a>, <a>pushPosition</a>,
--   and <a>SourcePos</a>.
popPosition :: MonadParsec e s m => m ()

-- | Get the number of tokens processed so far.
getTokensProcessed :: MonadParsec e s m => m Int

-- | Set the number of tokens processed so far.
setTokensProcessed :: MonadParsec e s m => Int -> m ()

-- | Return the tab width. The default tab width is equal to
--   <a>defaultTabWidth</a>. You can set a different tab width with the
--   help of <a>setTabWidth</a>.
getTabWidth :: MonadParsec e s m => m Pos

-- | Set tab width. If the argument of the function is not a positive
--   number, <a>defaultTabWidth</a> will be used.
setTabWidth :: MonadParsec e s m => Pos -> m ()

-- | <tt><a>setParserState</a> st</tt> sets the parser state to
--   <tt>st</tt>.
setParserState :: MonadParsec e s m => State s -> m ()

-- | <tt><a>dbg</a> label p</tt> parser works exactly like <tt>p</tt>, but
--   when it's evaluated it also prints information useful for debugging.
--   The <tt>label</tt> is only used to refer to this parser in the
--   debugging output. This combinator uses the <a>trace</a> function from
--   <a>Debug.Trace</a> under the hood.
--   
--   Typical usage is to wrap every sub-parser in misbehaving parser with
--   <a>dbg</a> assigning meaningful labels. Then give it a shot and go
--   through the print-out. As of current version, this combinator prints
--   all available information except for <i>hints</i>, which are probably
--   only interesting to the maintainer of Megaparsec itself and may be
--   quite verbose to output in general. Let me know if you would like to
--   be able to see hints in the debugging output.
--   
--   The output itself is pretty self-explanatory, although the following
--   abbreviations should be clarified (they are derived from the low-level
--   source code):
--   
--   <ul>
--   <li><tt>COK</tt>—“consumed OK”. The parser consumed input and
--   succeeded.</li>
--   <li><tt>CERR</tt>—“consumed error”. The parser consumed input and
--   failed.</li>
--   <li><tt>EOK</tt>—“empty OK”. The parser succeeded without consuming
--   input.</li>
--   <li><tt>EERR</tt>—“empty error”. The parser failed without consuming
--   input.</li>
--   </ul>
--   
--   Finally, it's not possible to lift this function into some monad
--   transformers without introducing surprising behavior (e.g. unexpected
--   state backtracking) or adding otherwise redundant constraints (e.g.
--   <a>Show</a> instance for state), so this helper is only available for
--   <a>ParsecT</a> monad, not <a>MonadParsec</a> in general.
dbg :: forall e s m a. (Stream s, ShowToken (Token s), ShowErrorComponent e, Show a) => String -> ParsecT e s m a -> ParsecT e s m a
instance GHC.Base.Monoid (Text.Megaparsec.Hints t)
instance Data.Semigroup.Semigroup (Text.Megaparsec.Hints t)
instance GHC.Generics.Generic (Text.Megaparsec.State s)
instance Data.Data.Data s => Data.Data.Data (Text.Megaparsec.State s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Text.Megaparsec.State s)
instance GHC.Show.Show s => GHC.Show.Show (Text.Megaparsec.State s)
instance (a ~ Text.Megaparsec.Stream.Tokens s, Data.String.IsString a, GHC.Classes.Eq a, Text.Megaparsec.Stream.Stream s, GHC.Classes.Ord e) => Data.String.IsString (Text.Megaparsec.ParsecT e s m a)
instance (GHC.Classes.Ord e, Text.Megaparsec.Stream.Stream s) => Text.Megaparsec.MonadParsec e s (Text.Megaparsec.ParsecT e s m)
instance Text.Megaparsec.MonadParsec e s m => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.State.Lazy.StateT st m)
instance Text.Megaparsec.MonadParsec e s m => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.State.Strict.StateT st m)
instance Text.Megaparsec.MonadParsec e s m => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Text.Megaparsec.MonadParsec e s m) => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Text.Megaparsec.MonadParsec e s m) => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Text.Megaparsec.MonadParsec e s m) => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.RWS.Lazy.RWST r w st m)
instance (GHC.Base.Monoid w, Text.Megaparsec.MonadParsec e s m) => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.RWS.Strict.RWST r w st m)
instance Text.Megaparsec.MonadParsec e s m => Text.Megaparsec.MonadParsec e s (Control.Monad.Trans.Identity.IdentityT m)
instance (Text.Megaparsec.Stream.Stream s, Data.Semigroup.Semigroup a) => Data.Semigroup.Semigroup (Text.Megaparsec.ParsecT e s m a)
instance (Text.Megaparsec.Stream.Stream s, GHC.Base.Monoid a) => GHC.Base.Monoid (Text.Megaparsec.ParsecT e s m a)
instance GHC.Base.Functor (Text.Megaparsec.ParsecT e s m)
instance Text.Megaparsec.Stream.Stream s => GHC.Base.Applicative (Text.Megaparsec.ParsecT e s m)
instance (GHC.Classes.Ord e, Text.Megaparsec.Stream.Stream s) => GHC.Base.Alternative (Text.Megaparsec.ParsecT e s m)
instance Text.Megaparsec.Stream.Stream s => GHC.Base.Monad (Text.Megaparsec.ParsecT e s m)
instance Text.Megaparsec.Stream.Stream s => Control.Monad.Fail.MonadFail (Text.Megaparsec.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Text.Megaparsec.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Reader.Class.MonadReader r m) => Control.Monad.Reader.Class.MonadReader r (Text.Megaparsec.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.State.Class.MonadState st m) => Control.Monad.State.Class.MonadState st (Text.Megaparsec.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Text.Megaparsec.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Error.Class.MonadError e' m) => Control.Monad.Error.Class.MonadError e' (Text.Megaparsec.ParsecT e s m)
instance (GHC.Classes.Ord e, Text.Megaparsec.Stream.Stream s) => GHC.Base.MonadPlus (Text.Megaparsec.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Text.Megaparsec.ParsecT e s m)
instance Control.Monad.Trans.Class.MonadTrans (Text.Megaparsec.ParsecT e s)
instance Control.DeepSeq.NFData s => Control.DeepSeq.NFData (Text.Megaparsec.State s)


-- | This module implements permutation parsers. The algorithm is described
--   in: <i>Parsing Permutation Phrases</i>, by Arthur Baars, Andres Loh
--   and Doaitse Swierstra. Published as a functional pearl at the Haskell
--   Workshop 2001.
module Text.Megaparsec.Perm

-- | The type <tt>PermParser s m a</tt> denotes a permutation parser that,
--   when converted by the <a>makePermParser</a> function, produces
--   instance of <a>MonadParsec</a> <tt>m</tt> that parses <tt>s</tt>
--   stream and returns a value of type <tt>a</tt> on success.
--   
--   Normally, a permutation parser is first build with special operators
--   like (<a>&lt;||&gt;</a>) and than transformed into a normal parser
--   using <a>makePermParser</a>.
data PermParser s m a

-- | The parser <tt>makePermParser perm</tt> parses a permutation of parser
--   described by <tt>perm</tt>. For example, suppose we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. This can be described by:
--   
--   <pre>
--   test = makePermParser $
--            (,,) &lt;$?&gt; ("", some (char 'a'))
--                 &lt;||&gt; char 'b'
--                 &lt;|?&gt; ('_', char 'c')
--   </pre>
makePermParser :: MonadParsec e s m => PermParser s m a -> m a

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input—use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: MonadParsec e s m => (a -> b) -> m a -> PermParser s m b
infixl 2 <$$>

-- | The expression <tt>f &lt;$?&gt; (x, p)</tt> creates a fresh
--   permutation parser consisting of parser <tt>p</tt>. The final result
--   of the permutation parser is the function <tt>f</tt> applied to the
--   return value of <tt>p</tt>. The parser <tt>p</tt> is optional—if it
--   cannot be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: MonadParsec e s m => (a -> b) -> (a, m a) -> PermParser s m b
infixl 2 <$?>

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input—use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: MonadParsec e s m => PermParser s m (a -> b) -> m a -> PermParser s m b
infixl 1 <||>

-- | The expression <tt>perm &lt;||&gt; (x, p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional—if it cannot be applied, the default value <tt>x</tt> will be
--   used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: MonadParsec e s m => PermParser s m (a -> b) -> (a, m a) -> PermParser s m b
infixl 1 <|?>


-- | A helper module to parse expressions. It can build a parser given a
--   table of operators.
module Text.Megaparsec.Expr

-- | This data type specifies operators that work on values of type
--   <tt>a</tt>. An operator is either binary infix or unary prefix or
--   postfix. A binary operator has also an associated associativity.
data Operator m a

-- | Non-associative infix
InfixN :: (m (a -> a -> a)) -> Operator m a

-- | Left-associative infix
InfixL :: (m (a -> a -> a)) -> Operator m a

-- | Right-associative infix
InfixR :: (m (a -> a -> a)) -> Operator m a

-- | Prefix
Prefix :: (m (a -> a)) -> Operator m a

-- | Postfix
Postfix :: (m (a -> a)) -> Operator m a

-- | <tt><a>makeExprParser</a> term table</tt> builds an expression parser
--   for terms <tt>term</tt> with operators from <tt>table</tt>, taking the
--   associativity and precedence specified in the <tt>table</tt> into
--   account.
--   
--   <tt>table</tt> is a list of <tt>[Operator m a]</tt> lists. The list is
--   ordered in descending precedence. All operators in one list have the
--   same precedence (but may have different associativity).
--   
--   Prefix and postfix operators of the same precedence associate to the
--   left (i.e. if <tt>++</tt> is postfix increment, than <tt>-2++</tt>
--   equals <tt>-1</tt>, not <tt>-3</tt>).
--   
--   Unary operators of the same precedence can only occur once (i.e.
--   <tt>--2</tt> is not allowed if <tt>-</tt> is prefix negate). If you
--   need to parse several prefix or postfix operators in a row, (like C
--   pointers—<tt>**i</tt>) you can use this approach:
--   
--   <pre>
--   manyUnaryOp = foldr1 (.) &lt;$&gt; some singleUnaryOp
--   </pre>
--   
--   This is not done by default because in some cases allowing repeating
--   prefix or postfix operators is not desirable.
--   
--   If you want to have an operator that is a prefix of another operator
--   in the table, use the following (or similar) wrapper instead of plain
--   <a>symbol</a>:
--   
--   <pre>
--   op n = (lexeme . try) (string n &lt;* notFollowedBy punctuationChar)
--   </pre>
--   
--   <a>makeExprParser</a> takes care of all the complexity involved in
--   building an expression parser. Here is an example of an expression
--   parser that handles prefix signs, postfix increment and basic
--   arithmetic:
--   
--   <pre>
--   expr = makeExprParser term table &lt;?&gt; "expression"
--   
--   term = parens expr &lt;|&gt; integer &lt;?&gt; "term"
--   
--   table = [ [ prefix  "-"  negate
--             , prefix  "+"  id ]
--           , [ postfix "++" (+1) ]
--           , [ binary  "*"  (*)
--             , binary  "/"  div  ]
--           , [ binary  "+"  (+)
--             , binary  "-"  (-)  ] ]
--   
--   binary  name f = InfixL  (f &lt;$ symbol name)
--   prefix  name f = Prefix  (f &lt;$ symbol name)
--   postfix name f = Postfix (f &lt;$ symbol name)
--   </pre>
makeExprParser :: MonadParsec e s m => m a -> [[Operator m a]] -> m a


-- | Commonly used character parsers.
module Text.Megaparsec.Char

-- | Parse a newline character.
newline :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a carriage return character followed by a newline character.
--   Return the sequence of characters parsed.
crlf :: forall e s m. (MonadParsec e s m, Token s ~ Char) => m (Tokens s)

-- | Parse a CRLF (see <a>crlf</a>) or LF (see <a>newline</a>) end of line.
--   Return the sequence of characters parsed.
eol :: forall e s m. (MonadParsec e s m, Token s ~ Char) => m (Tokens s)

-- | Parse a tab character.
tab :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Skip <i>zero</i> or more white space characters.
--   
--   See also: <a>skipMany</a> and <a>spaceChar</a>.
space :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Skip <i>one</i> or more white space characters.
--   
--   See also: <a>skipSome</a> and <a>spaceChar</a>.
space1 :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Parse a control character (a non-printing character of the Latin-1
--   subset of Unicode).
controlChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode space character, and the control characters: tab,
--   newline, carriage return, form feed, and vertical tab.
spaceChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an upper-case or title-case alphabetic Unicode character. Title
--   case is used by a small number of letter ligatures like the
--   single-character form of Lj.
upperChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a lower-case alphabetic Unicode character.
lowerChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an alphabetic Unicode character: lower-case, upper-case, or
--   title-case letter, or a letter of case-less scripts/modifier letter.
letterChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an alphabetic or numeric digit Unicode characters.
--   
--   Note that the numeric digits outside the ASCII range are parsed by
--   this parser but not by <a>digitChar</a>. Such digits may be part of
--   identifiers but are not used by the printer and reader to represent
--   numbers.
alphaNumChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a printable Unicode character: letter, number, mark,
--   punctuation, symbol or space.
printChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an ASCII digit, i.e between “0” and “9”.
digitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an octal digit, i.e. between “0” and “7”.
octDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a hexadecimal digit, i.e. between “0” and “9”, or “a” and “f”,
--   or “A” and “F”.
hexDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode mark character (accents and the like), which combines
--   with preceding characters.
markChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode numeric character, including digits from various
--   scripts, Roman numerals, etc.
numberChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode punctuation character, including various kinds of
--   connectors, brackets and quotes.
punctuationChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode symbol characters, including mathematical and currency
--   symbols.
symbolChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode space and separator characters.
separatorChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a character from the first 128 characters of the Unicode
--   character set, corresponding to the ASCII character set.
asciiChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a character from the first 256 characters of the Unicode
--   character set, corresponding to the ISO 8859-1 (Latin-1) character
--   set.
latin1Char :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | <tt><a>charCategory</a> cat</tt> parses character in Unicode General
--   Category <tt>cat</tt>, see <a>GeneralCategory</a>.
charCategory :: (MonadParsec e s m, Token s ~ Char) => GeneralCategory -> m (Token s)

-- | Return the human-readable name of Unicode General Category.
categoryName :: GeneralCategory -> String

-- | <tt><a>char</a> c</tt> parses a single character <tt>c</tt>.
--   
--   <pre>
--   semicolon = char ';'
--   </pre>
char :: MonadParsec e s m => Token s -> m (Token s)

-- | The same as <a>char</a> but case-insensitive. This parser returns the
--   actually parsed character preserving its case.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (char' 'e') "E"
--   'E'
--   
--   &gt;&gt;&gt; parseTest (char' 'e') "G"
--   1:1:
--   unexpected 'G'
--   expecting 'E' or 'e'
--   </pre>
char' :: (MonadParsec e s m, Token s ~ Char) => Token s -> m (Token s)

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: MonadParsec e s m => m (Token s)

-- | Match any character but the given one. It's a good idea to attach a
--   <a>label</a> to this parser manually.
notChar :: MonadParsec e s m => Token s -> m (Token s)

-- | <tt><a>oneOf</a> cs</tt> succeeds if the current character is in the
--   supplied collection of characters <tt>cs</tt>. Returns the parsed
--   character. Note that this parser cannot automatically generate the
--   “expected” component of error message, so usually you should label it
--   manually with <a>label</a> or (<a>&lt;?&gt;</a>).
--   
--   See also: <a>satisfy</a>.
--   
--   <pre>
--   digit = oneOf ['0'..'9'] &lt;?&gt; "digit"
--   </pre>
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> when you can because
--   it's faster when you have only a couple of tokens to compare to:
--   
--   <pre>
--   quoteFast = satisfy (\x -&gt; x == '\'' || x == '\"')
--   quoteSlow = oneOf "'\""
--   </pre>
oneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | As the dual of <a>oneOf</a>, <tt><a>noneOf</a> cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character. Note that this parser
--   cannot automatically generate the “expected” component of error
--   message, so usually you should label it manually with <a>label</a> or
--   (<a>&lt;?&gt;</a>).
--   
--   See also: <a>satisfy</a>.
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> and <a>notChar</a> when
--   you can because it's faster.
noneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | The parser <tt><a>satisfy</a> f</tt> succeeds for any character for
--   which the supplied function <tt>f</tt> returns <a>True</a>. Returns
--   the character that is actually parsed.
--   
--   <pre>
--   digitChar = satisfy isDigit &lt;?&gt; "digit"
--   oneOf cs  = satisfy (`elem` cs)
--   </pre>
satisfy :: MonadParsec e s m => (Token s -> Bool) -> m (Token s)

-- | <tt><a>string</a> s</tt> parses a sequence of characters given by
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod = string "div" &lt;|&gt; string "mod"
--   </pre>
string :: MonadParsec e s m => Tokens s -> m (Tokens s)

-- | The same as <a>string</a>, but case-insensitive. On success returns
--   string cased as actually parsed input.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string' "foobar") "foObAr"
--   "foObAr"
--   </pre>
string' :: (MonadParsec e s m, FoldCase (Tokens s)) => Tokens s -> m (Tokens s)


-- | High-level parsers to help you write your lexer. The module doesn't
--   impose how you should write your parser, but certain approaches may be
--   more elegant than others. Especially important theme is parsing of
--   white space, comments, and indentation.
--   
--   Parsing of white space is an important part of any parser. We propose
--   a convention where <b>every lexeme parser assumes no spaces before
--   the</b> <b>lexeme and consumes all spaces after the lexeme</b>; this
--   is what the <a>lexeme</a> combinator does, and so it's enough to wrap
--   every lexeme parser with <a>lexeme</a> to achieve this. Note that
--   you'll need to call <a>space</a> manually to consume any white space
--   before the first lexeme (i.e. at the beginning of the file).
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified Text.Megaparsec.Char.Lexer as L
--   </pre>
--   
--   To do lexing of byte streams, see <a>Text.Megaparsec.Byte.Lexer</a>.
module Text.Megaparsec.Char.Lexer

-- | <tt><a>space</a> sc lineComment blockComment</tt> produces parser that
--   can parse white space in general. It's expected that you create such a
--   parser once and pass it to other functions in this module as needed
--   (when you see <tt>spaceConsumer</tt> in documentation, usually it
--   means that something like <a>space</a> is expected there).
--   
--   <tt>sc</tt> is used to parse blocks of space characters. You can use
--   <a>space1</a> from <a>Text.Megaparsec.Char</a> for this purpose as
--   well as your own parser (if you don't want to automatically consume
--   newlines, for example). Make sure the parser does not succeed on empty
--   input though. In earlier version <a>spaceChar</a> was recommended, but
--   now parsers based on <a>takeWhile1P</a> are preferred because of their
--   speed.
--   
--   <tt>lineComment</tt> is used to parse line comments. You can use
--   <a>skipLineComment</a> if you don't need anything special.
--   
--   <tt>blockComment</tt> is used to parse block (multi-line) comments.
--   You can use <a>skipBlockComment</a> or <a>skipBlockCommentNested</a>
--   if you don't need anything special.
--   
--   If you don't want to allow a kind of comment, simply pass <a>empty</a>
--   which will fail instantly when parsing of that sort of comment is
--   attempted and <a>space</a> will just move on or finish depending on
--   whether there is more white space for it to consume.
space :: MonadParsec e s m => m () -> m () -> m () -> m ()

-- | This is a wrapper for lexemes. Typical usage is to supply the first
--   argument (parser that consumes white space, probably defined via
--   <a>space</a>) and use the resulting function to wrap parsers for every
--   lexeme.
--   
--   <pre>
--   lexeme  = L.lexeme spaceConsumer
--   integer = lexeme L.decimal
--   </pre>
lexeme :: MonadParsec e s m => m () -> m a -> m a

-- | This is a helper to parse symbols, i.e. verbatim strings. You pass the
--   first argument (parser that consumes white space, probably defined via
--   <a>space</a>) and then you can use the resulting function to parse
--   strings:
--   
--   <pre>
--   symbol    = L.symbol spaceConsumer
--   
--   parens    = between (symbol "(") (symbol ")")
--   braces    = between (symbol "{") (symbol "}")
--   angles    = between (symbol "&lt;") (symbol "&gt;")
--   brackets  = between (symbol "[") (symbol "]")
--   semicolon = symbol ";"
--   comma     = symbol ","
--   colon     = symbol ":"
--   dot       = symbol "."
--   </pre>
symbol :: MonadParsec e s m => m () -> Tokens s -> m (Tokens s)

-- | Case-insensitive version of <a>symbol</a>. This may be helpful if
--   you're working with case-insensitive languages.
symbol' :: (MonadParsec e s m, FoldCase (Tokens s)) => m () -> Tokens s -> m (Tokens s)

-- | Given comment prefix this function returns a parser that skips line
--   comments. Note that it stops just before the newline character but
--   doesn't consume the newline. Newline is either supposed to be consumed
--   by <a>space</a> parser or picked up manually.
skipLineComment :: (MonadParsec e s m, Token s ~ Char) => Tokens s -> m ()

-- | <tt><a>skipBlockComment</a> start end</tt> skips non-nested block
--   comment starting with <tt>start</tt> and ending with <tt>end</tt>.
skipBlockComment :: (MonadParsec e s m, Token s ~ Char) => Tokens s -> Tokens s -> m ()

-- | <tt><a>skipBlockCommentNested</a> start end</tt> skips possibly nested
--   block comment starting with <tt>start</tt> and ending with
--   <tt>end</tt>.
skipBlockCommentNested :: (MonadParsec e s m, Token s ~ Char) => Tokens s -> Tokens s -> m ()

-- | Return the current indentation level.
--   
--   The function is a simple shortcut defined as:
--   
--   <pre>
--   indentLevel = sourceColumn &lt;$&gt; getPosition
--   </pre>
indentLevel :: MonadParsec e s m => m Pos

-- | Fail reporting incorrect indentation error. The error has attached
--   information:
--   
--   <ul>
--   <li>Desired ordering between reference level and actual level</li>
--   <li>Reference indentation level</li>
--   <li>Actual indentation level</li>
--   </ul>
incorrectIndent :: MonadParsec e s m => Ordering -> Pos -> Pos -> m a

-- | <tt><a>indentGuard</a> spaceConsumer ord ref</tt> first consumes all
--   white space (indentation) with <tt>spaceConsumer</tt> parser, then it
--   checks the column position. Ordering between current indentation level
--   and the reference indentation level <tt>ref</tt> should be
--   <tt>ord</tt>, otherwise the parser fails. On success the current
--   column position is returned.
--   
--   When you want to parse a block of indentation, first run this parser
--   with arguments like <tt><a>indentGuard</a> spaceConsumer <a>GT</a>
--   <a>pos1</a></tt>—this will make sure you have some indentation. Use
--   returned value to check indentation on every subsequent line according
--   to syntax of your language.
indentGuard :: MonadParsec e s m => m () -> Ordering -> Pos -> m Pos

-- | Parse a non-indented construction. This ensures that there is no
--   indentation before actual data. Useful, for example, as a wrapper for
--   top-level function definitions.
nonIndented :: MonadParsec e s m => m () -> m a -> m a

-- | The data type represents available behaviors for parsing of indented
--   tokens. This is used in <a>indentBlock</a>, which see.
data IndentOpt m a b

-- | Parse no indented tokens, just return the value
IndentNone :: a -> IndentOpt m a b

-- | Parse many indented tokens (possibly zero), use given indentation
--   level (if <a>Nothing</a>, use level of the first indented token); the
--   second argument tells how to get the final result, and the third
--   argument describes how to parse an indented token
IndentMany :: (Maybe Pos) -> ([b] -> m a) -> (m b) -> IndentOpt m a b

-- | Just like <a>IndentMany</a>, but requires at least one indented token
--   to be present
IndentSome :: (Maybe Pos) -> ([b] -> m a) -> (m b) -> IndentOpt m a b

-- | Parse a “reference” token and a number of other tokens that have
--   greater (but the same) level of indentation than that of “reference”
--   token. Reference token can influence parsing, see <a>IndentOpt</a> for
--   more information.
--   
--   Tokens <i>must not</i> consume newlines after them. On the other hand,
--   the first argument of this function <i>must</i> consume newlines among
--   other white space characters.
indentBlock :: (MonadParsec e s m, Token s ~ Char) => m () -> m (IndentOpt m a b) -> m a

-- | Create a parser that supports line-folding. The first argument is used
--   to consume white space between components of line fold, thus it
--   <i>must</i> consume newlines in order to work properly. The second
--   argument is a callback that receives a custom space-consuming parser
--   as argument. This parser should be used after separate components of
--   line fold that can be put on different lines.
--   
--   An example should clarify the usage pattern:
--   
--   <pre>
--   sc = L.space (void spaceChar) empty empty
--   
--   myFold = L.lineFold sc $ \sc' -&gt; do
--     L.symbol sc' "foo"
--     L.symbol sc' "bar"
--     L.symbol sc  "baz" -- for the last symbol we use normal space consumer
--   </pre>
lineFold :: MonadParsec e s m => m () -> (m () -> m a) -> m a

-- | The lexeme parser parses a single literal character without quotes.
--   The purpose of this parser is to help with parsing of conventional
--   escape sequences. It's your responsibility to take care of character
--   literal syntax in your language (by surrounding it with single quotes
--   or similar).
--   
--   The literal character is parsed according to the grammar rules defined
--   in the Haskell report.
--   
--   Note that you can use this parser as a building block to parse various
--   string literals:
--   
--   <pre>
--   stringLiteral = char '"' &gt;&gt; manyTill L.charLiteral (char '"')
--   </pre>
--   
--   <b>Performance note</b>: the parser is not particularly efficient at
--   the moment.
charLiteral :: (MonadParsec e s m, Token s ~ Char) => m Char

-- | Parse an integer in decimal representation according to the format of
--   integer literals described in the Haskell report.
--   
--   If you need to parse signed integers, see <a>signed</a> combinator.
--   
--   <b>Note</b>: before version 6.0.0 the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
decimal :: forall e s m a. (MonadParsec e s m, Token s ~ Char, Integral a) => m a

-- | Parse an integer in octal representation. Representation of octal
--   number is expected to be according to the Haskell report except for
--   the fact that this parser doesn't parse “0o” or “0O” prefix. It is a
--   responsibility of the programmer to parse correct prefix before
--   parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   octal = char '0' &gt;&gt; char' 'o' &gt;&gt; L.octal
--   </pre>
--   
--   <b>Note</b>: before version 6.0.0 the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
octal :: forall e s m a. (MonadParsec e s m, Token s ~ Char, Integral a) => m a

-- | Parse an integer in hexadecimal representation. Representation of
--   hexadecimal number is expected to be according to the Haskell report
--   except for the fact that this parser doesn't parse “0x” or “0X”
--   prefix. It is a responsibility of the programmer to parse correct
--   prefix before parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   hexadecimal = char '0' &gt;&gt; char' 'x' &gt;&gt; L.hexadecimal
--   </pre>
--   
--   <b>Note</b>: before version 6.0.0 the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
hexadecimal :: forall e s m a. (MonadParsec e s m, Token s ~ Char, Integral a) => m a

-- | Parse a floating point value as a <a>Scientific</a> number.
--   <a>Scientific</a> is great for parsing of arbitrary precision numbers
--   coming from an untrusted source. See documentation in
--   <a>Data.Scientific</a> for more information.
--   
--   The parser can be used to parse integers or floating point values. Use
--   functions like <a>floatingOrInteger</a> from <a>Data.Scientific</a> to
--   test and extract integer or real values.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
scientific :: forall e s m. (MonadParsec e s m, Token s ~ Char) => m Scientific

-- | Parse a floating point number according to the syntax for floating
--   point literals described in the Haskell report.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
--   
--   <b>Note</b>: before version 6.0.0 the function returned <a>Double</a>,
--   i.e. it wasn't polymorphic in its return type.
--   
--   <b>Note</b>: in versions 6.0.0–6.1.1 this function accepted plain
--   integers.
float :: (MonadParsec e s m, Token s ~ Char, RealFloat a) => m a

-- | <tt><a>signed</a> space p</tt> parser parses an optional sign
--   character (“+” or “-”), then if there is a sign it consumes optional
--   white space (using <tt>space</tt> parser), then it runs parser
--   <tt>p</tt> which should return a number. Sign of the number is changed
--   according to the previously parsed sign character.
--   
--   For example, to parse signed integer you can write:
--   
--   <pre>
--   lexeme        = L.lexeme spaceConsumer
--   integer       = lexeme L.decimal
--   signedInteger = L.signed spaceConsumer integer
--   </pre>
signed :: (MonadParsec e s m, Token s ~ Char, Num a) => m () -> m a -> m a


-- | Commonly used binary parsers.
module Text.Megaparsec.Byte

-- | Parse a newline byte.
newline :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a carriage return character followed by a newline character.
--   Return the sequence of characters parsed.
crlf :: forall e s m. (MonadParsec e s m, Token s ~ Word8) => m (Tokens s)

-- | Parse a CRLF (see <a>crlf</a>) or LF (see <a>newline</a>) end of line.
--   Return the sequence of characters parsed.
eol :: forall e s m. (MonadParsec e s m, Token s ~ Word8) => m (Tokens s)

-- | Parse a tab character.
tab :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Skip <i>zero</i> or more white space characters.
--   
--   See also: <a>skipMany</a> and <a>spaceChar</a>.
space :: (MonadParsec e s m, Token s ~ Word8) => m ()

-- | Skip <i>one</i> or more white space characters.
--   
--   See also: <a>skipSome</a> and <a>spaceChar</a>.
space1 :: (MonadParsec e s m, Token s ~ Word8) => m ()

-- | Parse a control character.
controlChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a space character, and the control characters: tab, newline,
--   carriage return, form feed, and vertical tab.
spaceChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an upper-case character.
upperChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a lower-case alphabetic character.
lowerChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an alphabetic character: lower-case or upper-case.
letterChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an alphabetic or digit characters.
alphaNumChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a printable character: letter, number, mark, punctuation, symbol
--   or space.
printChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an ASCII digit, i.e between “0” and “9”.
digitChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an octal digit, i.e. between “0” and “7”.
octDigitChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a hexadecimal digit, i.e. between “0” and “9”, or “a” and “f”,
--   or “A” and “F”.
hexDigitChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a character from the first 128 characters of the Unicode
--   character set, corresponding to the ASCII character set.
asciiChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | <tt><a>char</a> c</tt> parses a single character <tt>c</tt>.
--   
--   <pre>
--   semicolon = char ';'
--   </pre>
char :: MonadParsec e s m => Token s -> m (Token s)

-- | The same as <tt>char</tt> but case-insensitive. This parser returns
--   the actually parsed character preserving its case.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (char' 101) "E"
--   69 -- 'E'
--   
--   &gt;&gt;&gt; parseTest (char' 101) "G"
--   1:1:
--   unexpected 'G'
--   expecting 'E' or 'e'
--   </pre>
char' :: (MonadParsec e s m, Token s ~ Word8) => Token s -> m (Token s)

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: MonadParsec e s m => m (Token s)

-- | Match any character but the given one. It's a good idea to attach a
--   <a>label</a> to this parser manually.
notChar :: MonadParsec e s m => Token s -> m (Token s)

-- | <tt><a>oneOf</a> cs</tt> succeeds if the current character is in the
--   supplied collection of characters <tt>cs</tt>. Returns the parsed
--   character. Note that this parser cannot automatically generate the
--   “expected” component of error message, so usually you should label it
--   manually with <a>label</a> or (<a>&lt;?&gt;</a>).
--   
--   See also: <a>satisfy</a>.
--   
--   <pre>
--   digit = oneOf ['0'..'9'] &lt;?&gt; "digit"
--   </pre>
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> when you can because
--   it's faster when you have only a couple of tokens to compare to:
--   
--   <pre>
--   quoteFast = satisfy (\x -&gt; x == '\'' || x == '\"')
--   quoteSlow = oneOf "'\""
--   </pre>
oneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | As the dual of <a>oneOf</a>, <tt><a>noneOf</a> cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character. Note that this parser
--   cannot automatically generate the “expected” component of error
--   message, so usually you should label it manually with <a>label</a> or
--   (<a>&lt;?&gt;</a>).
--   
--   See also: <a>satisfy</a>.
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> and <a>notChar</a> when
--   you can because it's faster.
noneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | The parser <tt><a>satisfy</a> f</tt> succeeds for any character for
--   which the supplied function <tt>f</tt> returns <a>True</a>. Returns
--   the character that is actually parsed.
--   
--   <pre>
--   digitChar = satisfy isDigit &lt;?&gt; "digit"
--   oneOf cs  = satisfy (`elem` cs)
--   </pre>
satisfy :: MonadParsec e s m => (Token s -> Bool) -> m (Token s)

-- | <tt><a>string</a> s</tt> parses a sequence of characters given by
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod = string "div" &lt;|&gt; string "mod"
--   </pre>
string :: MonadParsec e s m => Tokens s -> m (Tokens s)

-- | The same as <a>string</a>, but case-insensitive. On success returns
--   string cased as actually parsed input.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string' "foobar") "foObAr"
--   "foObAr"
--   </pre>
string' :: (MonadParsec e s m, FoldCase (Tokens s)) => Tokens s -> m (Tokens s)


-- | Stripped-down version of <a>Text.Megaparsec.Char.Lexer</a> for streams
--   of bytes.
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified Text.Megaparsec.Byte.Lexer as L
--   </pre>
module Text.Megaparsec.Byte.Lexer

-- | <tt><a>space</a> sc lineComment blockComment</tt> produces parser that
--   can parse white space in general. It's expected that you create such a
--   parser once and pass it to other functions in this module as needed
--   (when you see <tt>spaceConsumer</tt> in documentation, usually it
--   means that something like <a>space</a> is expected there).
--   
--   <tt>sc</tt> is used to parse blocks of space characters. You can use
--   <a>space1</a> from <a>Text.Megaparsec.Char</a> for this purpose as
--   well as your own parser (if you don't want to automatically consume
--   newlines, for example). Make sure the parser does not succeed on empty
--   input though. In earlier version <a>spaceChar</a> was recommended, but
--   now parsers based on <a>takeWhile1P</a> are preferred because of their
--   speed.
--   
--   <tt>lineComment</tt> is used to parse line comments. You can use
--   <a>skipLineComment</a> if you don't need anything special.
--   
--   <tt>blockComment</tt> is used to parse block (multi-line) comments.
--   You can use <a>skipBlockComment</a> or <a>skipBlockCommentNested</a>
--   if you don't need anything special.
--   
--   If you don't want to allow a kind of comment, simply pass <a>empty</a>
--   which will fail instantly when parsing of that sort of comment is
--   attempted and <a>space</a> will just move on or finish depending on
--   whether there is more white space for it to consume.
space :: MonadParsec e s m => m () -> m () -> m () -> m ()

-- | This is a wrapper for lexemes. Typical usage is to supply the first
--   argument (parser that consumes white space, probably defined via
--   <a>space</a>) and use the resulting function to wrap parsers for every
--   lexeme.
--   
--   <pre>
--   lexeme  = L.lexeme spaceConsumer
--   integer = lexeme L.decimal
--   </pre>
lexeme :: MonadParsec e s m => m () -> m a -> m a

-- | This is a helper to parse symbols, i.e. verbatim strings. You pass the
--   first argument (parser that consumes white space, probably defined via
--   <a>space</a>) and then you can use the resulting function to parse
--   strings:
--   
--   <pre>
--   symbol    = L.symbol spaceConsumer
--   
--   parens    = between (symbol "(") (symbol ")")
--   braces    = between (symbol "{") (symbol "}")
--   angles    = between (symbol "&lt;") (symbol "&gt;")
--   brackets  = between (symbol "[") (symbol "]")
--   semicolon = symbol ";"
--   comma     = symbol ","
--   colon     = symbol ":"
--   dot       = symbol "."
--   </pre>
symbol :: MonadParsec e s m => m () -> Tokens s -> m (Tokens s)

-- | Case-insensitive version of <a>symbol</a>. This may be helpful if
--   you're working with case-insensitive languages.
symbol' :: (MonadParsec e s m, FoldCase (Tokens s)) => m () -> Tokens s -> m (Tokens s)

-- | Given comment prefix this function returns a parser that skips line
--   comments. Note that it stops just before the newline character but
--   doesn't consume the newline. Newline is either supposed to be consumed
--   by <a>space</a> parser or picked up manually.
skipLineComment :: (MonadParsec e s m, Token s ~ Word8) => Tokens s -> m ()

-- | <tt><a>skipBlockComment</a> start end</tt> skips non-nested block
--   comment starting with <tt>start</tt> and ending with <tt>end</tt>.
skipBlockComment :: (MonadParsec e s m, Token s ~ Word8) => Tokens s -> Tokens s -> m ()

-- | <tt><a>skipBlockCommentNested</a> start end</tt> skips possibly nested
--   block comment starting with <tt>start</tt> and ending with
--   <tt>end</tt>.
skipBlockCommentNested :: (MonadParsec e s m, Token s ~ Word8) => Tokens s -> Tokens s -> m ()

-- | Parse an integer in decimal representation according to the format of
--   integer literals described in the Haskell report.
--   
--   If you need to parse signed integers, see <a>signed</a> combinator.
decimal :: forall e s m a. (MonadParsec e s m, Token s ~ Word8, Integral a) => m a

-- | Parse an integer in octal representation. Representation of octal
--   number is expected to be according to the Haskell report except for
--   the fact that this parser doesn't parse “0o” or “0O” prefix. It is a
--   responsibility of the programmer to parse correct prefix before
--   parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   octal = char '0' &gt;&gt; char' 'o' &gt;&gt; L.octal
--   </pre>
octal :: forall e s m a. (MonadParsec e s m, Token s ~ Word8, Integral a) => m a

-- | Parse an integer in hexadecimal representation. Representation of
--   hexadecimal number is expected to be according to the Haskell report
--   except for the fact that this parser doesn't parse “0x” or “0X”
--   prefix. It is a responsibility of the programmer to parse correct
--   prefix before parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   hexadecimal = char '0' &gt;&gt; char' 'x' &gt;&gt; L.hexadecimal
--   </pre>
hexadecimal :: forall e s m a. (MonadParsec e s m, Token s ~ Word8, Integral a) => m a

-- | Parse a floating point value as a <a>Scientific</a> number.
--   <a>Scientific</a> is great for parsing of arbitrary precision numbers
--   coming from an untrusted source. See documentation in
--   <a>Data.Scientific</a> for more information.
--   
--   The parser can be used to parse integers or floating point values. Use
--   functions like <a>floatingOrInteger</a> from <a>Data.Scientific</a> to
--   test and extract integer or real values.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
scientific :: forall e s m. (MonadParsec e s m, Token s ~ Word8) => m Scientific

-- | Parse a floating point number according to the syntax for floating
--   point literals described in the Haskell report.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
--   
--   <b>Note</b>: in versions 6.0.0–6.1.1 this function accepted plain
--   integers.
float :: (MonadParsec e s m, Token s ~ Word8, RealFloat a) => m a

-- | <tt><a>signed</a> space p</tt> parser parses an optional sign
--   character (“+” or “-”), then if there is a sign it consumes optional
--   white space (using <tt>space</tt> parser), then it runs parser
--   <tt>p</tt> which should return a number. Sign of the number is changed
--   according to the previously parsed sign character.
--   
--   For example, to parse signed integer you can write:
--   
--   <pre>
--   lexeme        = L.lexeme spaceConsumer
--   integer       = lexeme L.decimal
--   signedInteger = L.signed spaceConsumer integer
--   </pre>
signed :: (MonadParsec e s m, Token s ~ Word8, Num a) => m () -> m a -> m a
